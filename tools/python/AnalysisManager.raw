#!/usr/bin/python

import os
import sys
sys.path.append(os.path.join(os.path.split(os.path.split(os.path.realpath(__file__))[0])[0], "tools", "python"))
reload(sys)
sys.setdefaultencoding('utf-8')
from get_s95 import find_s95_obs, find_s95_exp
from global_functions import *
import json
from math import sqrt
from multiprocessing import Pool
from organize_paths_and_files import *
import re
import time

# Global variable to keep track if indentation
Printlevel = 1

def myprint(text):
    """Indents text according to Printlevel"""
    print "    "*Printlevel + text
        
def ask(question, allowed_answers="@", allow_empty=False):
    """Asks user a question with right indentation and only accepts a predefined set
         of answers ("@" allows everything, "#" allows numbers only)"""
    global Printlevel
    if question != "":
      myprint(question)
    Printlevel += 1
    while True:
        answer = raw_input("    "*Printlevel)
        if allow_empty and answer == "": # zero entry is only allowed if explicitly told
          break          
        elif answer != "" and allowed_answers == "@": # @ allows everything
            break
        elif answer != "" and allowed_answers == "#" and all(c in '+-.0123456789' for c in answer): # # only allows numbers
            answer = str(float(answer)) # integer numbers are always stored as floats to make sure that "1" and "1." are considered as equal
            break
        elif answer != "" and answer in allowed_answers: # allowed_answers can be a string which always includes ""
            break
        print "    "*Printlevel + " (Invalid Input)"
    Printlevel -= 1
    return answer

def ask_multiline(question, allowed_answers="@"):
    """runs 'ask' and stores answers in list as long as no empty line appears"""
    lines = list()
    allow_empty = False # Allow them after the first item was entered
    while True:
        line = ask(question, allowed_answers, allow_empty)
        allow_empty = True
        question = "" # Only ask the question on the first iteration
        if line == "":
            break
        lines.append(line)
    return lines

def myround(x, y):
    """ Rounds number x to the same number of digits as y """
    y_comma_split = str(y).split(".")
    # if y is an integer, return integer x
    if len(y_comma_split) == 1:
        return int(round(x))
    # otherwise, find number of digits after the comma in y and round x accordingly
    ndigits = len(y_comma_split[1])
    return round(x, ndigits)

def s95_obs(x):    
    """ Runs s95_obs script and rounds result to accuracy of B"""
    res = find_s95_obs(float(x[0]), 0., float(x[1]), float(x[2]))
    return myround(res, x[1])

def s95_exp(x): 
    """ Runs s95_exp script and rounds result to accuracy of B""" 
    res = find_s95_exp(float(x[0]), float(x[1]), float(x[2]))
    # round to same number of digits as bkg
    return myround(res, x[1])

def count_finished(queues):
    """ Checks how many queued processes in all queues have finished already"""
    count, total = 0, 0
    for queue in queues:
        for i in range(len(queue)):
            process = queue[i]
            total += 1
            if process.ready():
                count += 1
    return (count, total)


def write_analysis_parameters(parameters):    
    """ Writes the _var.j file of given a set of parameters """
    global Printlevel
    analysis = parameters["analysis"]
    files = get_analysis_files([analysis])
    jfile = open(files['analysis_settings'][analysis], "wb")
    jfile.write(json.dumps(parameters, sort_keys=True, indent=2))
    jfile.close()
    myprint(" - Variable values saved in " + files['analysis_settings'][analysis])

def ask_for_general_information(parameters):    
    """ Asks for standard information (name, description, author, lumi)
            and stores output in parameters """
    global Printlevel
    BASELEVEL = Printlevel
    while True:        
        try:
            Printlevel = BASELEVEL
            Printlevel += 1
            parameters["analysis"] = ask("Analysis Name: ")    
            # Check whether parameter file already exists
            files = get_analysis_files([parameters["analysis"]])
            if os.path.isfile(files['analysis_settings'][parameters["analysis"]]):
                skip = ask("A parameter file for this analysis already exists! [(u)se, (o)verwrite]", "uo")
                if skip == "u":
                    # Writes necessary files
                    parameters = read_analysis_parameters(parameters["analysis"])
                    write_analysis_parameters(parameters)             
                    add_analysis_sources(parameters)    
                    if parameters["expectation_known"] == "y":
                      add_analysis_reference(parameters)    
                    Printlevel -= 1
                    myprint("Analysis " + parameters["analysis"] + " has been added successfully!")
                    myprint("Run 'autoreconf; ./configure {parameters}; make' to compile the new sources.")
                    myprint("You can find the list '{parameters}' you configured CheckMATE originally with at the beginning of the file 'config.log'.")
                    myprint("")
                    exit("")
            parameters["author"] = ask("Your Name (to declare the analysis author): ")
            parameters["authoremail"] = ask("Your Email: ")                
            parameters["short_info"] = ask("Analysis Description (short, one line): ")
            # Replace two spaces by one, as two spaces are internally interpreted as column separators in CheckMATE
            while parameters["short_info"].find("    ") != -1:
                parameters["short_info"] = parameters["short_info"].replace("    ", " ")
        
            parameters["long_info"] = ask_multiline("Description (long, multiple lines, finish with empty line: ")
            parameters["lumi"] = ask("Luminosity (in fb^-1): ", "#")
            parameters["cr"] = ask("Do you plan to implement control regions to that analysis? [(y)es, (n)o]", "yn")
            break
        except KeyboardInterrupt:
            try:
                myprint('')
                myprint('>>> Caught Interrupting Signal')
                myprint('>>> Press any key to restart current question block')
                myprint('        or resend signal to abort')
                raw_input("")
            except KeyboardInterrupt:
                exit(1)
    Printlevel = BASELEVEL
    myprint('')
    return parameters

def ask_for_signal_region_information(parameters):
    """ Fills the signal region table with information like B, dB, O and starts S95 calculations.
            Returns parameters and queueus to access the S95 results later."""
    global Printlevel
    BASELEVEL = Printlevel    
    
    myprint("Information: We are now going to ask you which numbers you want to provide for each signal region. ")
    myprint("The following items are possible:") 
    Printlevel += 1
    allowed = ["obs", "bkg", "bkg_err_stat", "bkg_err_sys", "bkg_errm_sys", "bkg_errp_sys", "bkg_err", "bkg_errp", "bkg_errm"]
    myprint("obs:                    Observed number of events")
    myprint("bkg:                    Expected number of background events")
    myprint("bkg_err:            Expected total error on bkg ")
    myprint("bkg_errp:         Expected total upper error (in case of asymmetric errors)")
    myprint("bkg_errm:         Expected total lower error (in case of asymmetric errors)")
    myprint("bkg_err_stat: Expected statistical error on bkg")
    myprint("bkg_err_sys:    Expected systematical error on bkg (in case of symmetric errors)")
    myprint("bkg_errp_sys: Expected systematical upper error (in case of asymmetric errors)")
    myprint("bkg_errm_sys: Expected systematical lower error (in case of asymmetric errors)")                    
    Printlevel -= 1
    myprint("Note that not all of these numbers have to be given (e.g. you don't have to give the total error if you give the individual stat and sys contributions)")
    myprint("However, there are some requirements, about which you will be warned if you don't meet them (e.g. giving xyz_errp without xyz_errm)")
    myprint("The standard, minimum set of information consists of obs, bkg and bkg_err")
    while True:  # Pseudoloop that breaks if loop code ended successfully
        Printlevel = BASELEVEL+1
        parameters["info_set"] = ask_multiline("List all categories you want to supply (one per line)", allowed)
        if "bkg" not in parameters["info_set"]:
            myprint("You have to provide the number of background events! Starting Over.")
        elif "obs" not in parameters["info_set"]:
            myprint("You have to provide the number of observed events! Starting Over.")
        elif "bkg_err" not in parameters["info_set"] and "bkg_errp" not in parameters["info_set"] and "bkg_err_sys" not in parameters["info_set"] and "bkg_errp_sys" not in parameters["info_set"]:
            myprint("You have to provide an error on the number of background events! Starting Over")
        elif ("bkg_err_sys" in parameters["info_set"] or "bkg_errp_sys" in parameters["info_set"]) and "bkg_err_stat" not in parameters["info_set"]:
            myprint("You cannot give the systematic error without the statistical error! Starting Over")
        elif "bkg_errp_sys" in parameters["info_set"] and "bkg_errm_sys" not in parameters["info_set"]:
            myprint("You have to give both sides in case of asymmetric errors! Starting Over")
        elif "bkg_errp" in parameters["info_set"] and "bkg_errm" not in parameters["info_set"]:
            myprint("You have to give both sides in case of asymmetric errors! Starting Over")
        else:
            break
          
    PRINTLEVEL = BASELEVEL
    myprint("The set of information you entered is valid.")
    myprint("You now have to add the numbers for each of the given signal regions.")
    myprint("Note that while you enter more numbers, the corresponding model independent")
    myprint(" 95\% confidence limits for the items you have already entered are calculated")
    myprint(" in the background. ")
    
    try:
        while True:  # Pseudoloop that breaks if loop code ended successfully
            Printlevel = BASELEVEL+1
            parameters["reference_data"] = dict()            
            # Needed for internal evaluation of S95 values
            pool = Pool(processes=1)
            S95obs_queue, S95exp_queue, S95_inputs = list(), list(), list()
            for sr in parameters["signal_regions"]:
                myprint(sr)
                Printlevel += 1    
                parameters["reference_data"][sr] = dict()
                for info in parameters["info_set"]:
                    parameters["reference_data"][sr][info] = ask(info + ": ")
                
                # Find the information necessary for S95 calculation
                obs = parameters["reference_data"][sr]["obs"]
                bkg = parameters["reference_data"][sr]["bkg"]
                                                                                                                                                                                                                                                                                                                                        
                bkg_err = 0
                if "bkg_err" in parameters["reference_data"][sr]:
                    bkg_err = parameters["reference_data"][sr]["bkg_err"]
                elif "bkg_errp" in reference_data[sr]:
                    # Asymmetric error: as a rough approximation, use the mean of the squares                                                                                                                                                                                                                                                    
                    bkg_err = str(myround(sqrt(float(parameters["reference_data"][sr]["bkg_errp"]) ** 2 + float(parameters["reference_data"][sr]["bkg_errm"]) ** 2) / sqrt(2.), parameters["reference_data"][sr]["bkg_errp"]))
                elif "bkg_err_sys" in reference_data[sr]:
                    # Total error = independent quadratic sum of statistical and systematical component                                                                                                                                                                                                                                
                    bkg_err = str(myround(sqrt(float(parameters["reference_data"][sr]["bkg_err_stat"]) ** 2 + float(parameters["reference_data"][sr]["bkg_err_sys"]) ** 2), parameters["reference_data"][sr]["bkg_err_stat"]))
                elif "bkg_err_sysp" in reference_data[sr]:
                    bkg_err = str(myround(sqrt(float(parameters["reference_data"][sr]["bkg_err_stat"]) ** 2 + (float(parameters["reference_data"][sr]["bkg_err_sysp"]) ** 2) / 2. + (float(parameters["reference_data"][sr]["bkg_err_sysp"]) ** 2) / 2.), parameters["reference_data"][sr]["bkg_err_stat"]))
                else:
                    exit("ERROR: Something went wrong while trying to calculate bkg_err. Aborting.")
                    
                # Push S95 calculations into queue                
                S95obs_queue.append(pool.apply_async(s95_obs, [(obs, bkg, bkg_err)]))
                S95exp_queue.append(pool.apply_async(s95_exp, [(obs, bkg, bkg_err)]))
                S95_inputs.append((sr, obs, bkg, bkg_err))
                progress = count_finished((S95obs_queue, S95exp_queue))
                myprint("S95obs and S95exp values are calculated internally (progress: " + str(progress[0]) + " / " + str(progress[1]) + ")")
                Printlevel -= 1                    
            parameters["info_set"].append("S95_obs")  # Added internally since internally calculated
            parameters["info_set"].append("S95_exp")  # Added internally since internally calculated
            break
    except KeyboardInterrupt:
        try:
            myprint('')
            myprint('>>> Caught Interrupting Signal')
            myprint('>>> Press any key to restart current question block')
            myprint('        or resend signal to abort')
            raw_input("")
        except KeyboardInterrupt:
            exit(1)
    Printlevel = BASELEVEL
    return parameters, S95obs_queue, S95exp_queue, S95_inputs

def ask_for_detector_information(parameters):
    """ Asks for final state properties that have to be determined within Delphes like
            jet properties and lepton isolation critera."""
    global Printlevel
    BASELEVEL = Printlevel
    while True:        
        try:
            Printlevel = BASELEVEL
            Printlevel += 1
            myprint("3.1: Miscellaneous")            
            Printlevel += 1
            parameters["experiment"] = ask("To which experiment does the analysis correspond? [(A)TLAS, (C)MS]", "AC");
            Printlevel -= 1
             
            myprint("3.2: Electron Isolation")            
            parameters["electron_iso_source"] = ["c"]
            parameters["electron_iso_dR"] = ["0.2"]
            parameters["electron_iso_ptmin"] = ["0.1"]
            parameters["electron_iso_absorrel"] = ["r"]
            parameters["electron_iso_ptratiomax"] = ["0.2"] 
            parameters["electron_niso"] = 1
            Printlevel += 1
            c = ask("Do you need any particular isolation criterion? [(y)es, (n)o]", "yn")
            while c != "n":
                myprint("Isolation " + str(parameters["electron_niso"]) + ":")
                parameters["electron_niso"] += 1
                Printlevel += 1                         
                parameters["electron_iso_source"].append(ask("Which objects should be considered for isolation? [(t)racks, (c)alo objects?]", "tc"))
                parameters["electron_iso_ptmin"].append(ask("What is the minimum pt of a surrounding object to be used for isolation (default ATLAS values: tracks=0.4, calo=0.1)? [in GeV]", "#"))
                parameters["electron_iso_dR"].append(ask("What is the dR used for isolation?", "#"))
                parameters["electron_iso_absorrel"].append(ask("Is there an absolute or a relative upper limit for the surrounding pt? [(a)bsolute, (r)elative]", "ar"))
                if parameters["electron_iso_absorrel"][-1] == "a":
                    parameters["electron_iso_ptratiomax"].append(ask("What is the maximum surrounding pt used for isolation [in GeV]?", "#"))
                else:
                    parameters["electron_iso_ptratiomax"].append(ask("What is the maximum pt ratio used for isolation?", "#"))
                Printlevel -= 1
                myprint("")
                c = ask("Do you need more isolation criteria? [(y)es, (n)o]", "yn")
            Printlevel -= 1
            
            myprint("3.3: Muon Isolation")            
            parameters["muon_iso_source"] = ["t"]
            parameters["muon_iso_dR"] = ["0.05"]
            parameters["muon_iso_ptmin"] = ["0.5"]
            parameters["muon_iso_absorrel"] = ["r"]
            parameters["muon_iso_ptratiomax"] = ["0.2"] 
            parameters["muon_niso"] = 1 
            Printlevel += 1
            c = ask("Do you need any particular isolation criterion? [(y)es, (n)o]", "yn")
            while c != "n":
                myprint("Isolation " + str(parameters["muon_niso"]) + ":")
                parameters["muon_niso"] += 1
                Printlevel += 1                         
                parameters["muon_iso_source"].append(ask("Which objects should be considered for isolation? [(t)racks, (c)alo objects?]", "tc"))
                parameters["muon_iso_ptmin"].append(ask("What is the minimum pt of a surrounding object to be used for isolation (default ATLAS values: tracks=0.4, calo=0.1)? [in GeV]", "#"))
                parameters["muon_iso_dR"].append(ask("What is the dR used for isolation?", "#"))
                parameters["muon_iso_absorrel"].append(ask("Is there an absolute or a relative upper limit for the surrounding pt? [(a)bsolute, (r)elative]", "ar"))
                if parameters["muon_iso_absorrel"][-1] == "a":
                    parameters["muon_iso_ptratiomax"].append(ask("What is the maximum surrounding pt used for isolation [in GeV]?", "#"))
                else:
                    parameters["muon_iso_ptratiomax"].append(ask("What is the maximum pt ratio used for isolation?", "#"))
                Printlevel -= 1
                myprint("")
                c = ask("Do you need more isolation criteria? [(y)es, (n)o]", "yn")
            Printlevel -= 1
            
            myprint("3.4: Photon Isolation")
            parameters["photon_iso_source"] = ["c"]
            parameters["photon_iso_dR"] = ["0.2"]
            parameters["photon_iso_ptmin"] = ["0.1"]
            parameters["photon_iso_absorrel"] = ["r"]
            parameters["photon_iso_ptratiomax"] = ["0.2"] 
            parameters["photon_niso"] = 1 
            Printlevel += 1
            c = ask("Do you need any particular isolation criterion? [(y)es, (n)o]", "yn")
            while c == "y":
                myprint("Isolation " + str(parameters["photon_niso"]) + ":")
                parameters["photon_niso"] += 1
                Printlevel += 1                         
                parameters["photon_iso_source"].append(ask("Which objects should be considered for isolation? [(t)racks, (c)alo objects?", "tc"))
                parameters["photon_iso_ptmin"].append(ask("What is the minimum pt of a surrounding object to be used for isolation (default ATLAS values: tracks=0.4, calo=0.1)? [in GeV]", "#"))
                parameters["photon_iso_dR"].append(ask("What is the dR used for isolation?", "#"))
                parameters["photon_iso_absorrel"].append(ask("Is there an absolute or a relative upper limit for the surrounding pt? [(a)bsolute, (r)elative]", "ar"))
                if parameters["photon_iso_absorrel"][-1] == "a":
                    parameters["photon_iso_ptratiomax"].append(ask("What is the maximum surrounding pt used for isolation [in GeV]?", "#"))
                else:
                    parameters["photon_iso_ptratiomax"].append(ask("What is the maximum pt ratio used for isolation?", "#"))
                Printlevel -= 1
                myprint("")
                c = ask("Do you need more isolation criteria? [(y)es, (n)o]", "yn")
            Printlevel -= 1
            
            myprint("3.5: Jets")
            Printlevel += 1
            parameters["jets_conedR"] = ask("Which dR cone radius do you want to use for the FastJet algorithm?", "#")
            parameters["jets_ptmin"] = ask("What is the minimum pt of a jet? [in GeV]", "#")
            parameters["jets_second"] = ask("Do you need a separate, extra type of jet? [(y)es, (n)o]", "yn")
            if parameters["jets_second"] == "y":
                parameters["jets_conedR_second"] = ask("Second Jet: Which dR cone radius do you want to use for the FastJet algorithm?", "#")
                parameters["jets_ptmin_second"] = ask("Second Jet: What is the minimum pt of a jet? [in GeV]", "#")
            
            parameters["jets_btagging"] = ask("Do you want to use b-tagging? [(y)es, (n)o]", "yn")
            if parameters["jets_btagging"] == "y":
                c = "y"
                parameters["jets_btagging_n"] = 0
                parameters["jets_btagging_eff"] = []
            
            while c == "y":
                parameters["jets_btagging_n"] += 1
                myprint("b-Tagging " + str(parameters["jets_btagging_n"]) + ":")
                Printlevel += 1
                parameters["jets_btagging_eff"].append(ask("What is the signal efficiency to tag a b-jet? [in %]", "#"))
                Printlevel -= 1
                c = ask("Do you need more b tags? [(y)es, (n)o]", "yn")
                
            parameters["jets_tautagging"] = ask("Do you want to use tau-tagging? [(y)es, (n)o]", "yn")        
            break
        except KeyboardInterrupt:
            try:
                myprint('')
                myprint('>>> Caught Interrupting Signal')
                myprint('>>> Press any key to restart current question block')
                myprint('        or resend signal to abort')
                raw_input("")
            except KeyboardInterrupt:
                exit(1)
    Printlevel = BASELEVEL
    return parameters
  
def check_queue_progress(parameters, S95obs_queue, S95exp_queue, S95_inputs):
    """Checks the progress of the internal S95 calculation queues and waits until
         all finished. """
    global Printlevel
    myprint("")
    myprint("All necessary information has been entered. Before the AnalysisManager")
    myprint(" can create all required files, the internal S95obs and S95exp")
    myprint(" calculations have to finish. The calculation should take between 10 and 100s")
    myprint(" per point.") 
    Printlevel += 2
    while True:        
        progress = count_finished((S95obs_queue, S95exp_queue))
        if progress[0] == progress[1]:
            myprint("... done!")
            break                        
        myprint("... Progress: " + str(progress[0]) + "/" + str(progress[1]))
        time.sleep(10)
    Printlevel -= 2
    
    myprint("Please check the below results for sanity. If anything looks")
    myprint(" suspicious, please contact the CheckMATE authors.")
    Printlevel += 1
    myprint("obs    bkg    bkgerr    S95obs    S95exp")
    for i in range(len(S95_inputs)):
        analysis = S95_inputs[i][0]
        obs, bkg, bkgerr = S95_inputs[i][1:4]
        S95obs, S95exp = S95obs_queue[i].get(), S95exp_queue[i].get()
        # Should bkg and obs be identical, the S95 values should be identical too.
        # For numerical reasons, it can happen that they aren't. In that case, choose
        # the mean
        if bkg == obs:
          S95 = myround((S95exp+S95obs)/2., bkg)
          S95exp = S95obs = S95
        parameters["reference_data"][analysis]["S95_obs"] = str(S95obs)
        parameters["reference_data"][analysis]["S95_exp"] = str(S95exp)
        myprint(str(obs) + "    " + str(bkg) + "    " + str(bkgerr) + "    " + str(S95obs) + "    " + str(S95exp))
    ask("(Press any key to continue)", "@", True)
    Printlevel -= 1
    return parameters

def add_analysis_sources(parameters):
    global Printlevel
    analysis = parameters["analysis"]  
    
    files = get_analysis_files([analysis]) 
    
    if parameters["experiment"] == 'A':                  
      template_file = open(files['analysis_template_source_atlas'], "r")
    if parameters["experiment"] == 'C':                  
      template_file = open(files['analysis_template_source_cms'], "r")  
      
    contents = template_file.read()
    template_file.close()    
    contents = contents.replace("@@analysis@@", analysis).replace("@@Analysis@@", analysis.capitalize()).replace("@@ANALYSIS@@", analysis.upper())
    contents = contents.replace("@@lumi@@", parameters["lumi"])
    contents = contents.replace("@@author@@", parameters["author"])
    contents = contents.replace("@@authoremail@@", parameters["authoremail"])
    contents = contents.replace("@@longInfo@@", str(parameters["long_info"]).replace("[u'", '"# ').replace("['", '"# ').replace("']", '\\n"').replace("', u'", '\\n"\n     "# ').replace("', '", '\\n"\n     "# '))
    signal_region_string = ""
    for sr in parameters["signal_regions"]:
        signal_region_string += sr + ";"
    contents = contents.replace("@@signalregions@@", signal_region_string);
    real_file = open(files['analysis_source'][analysis], "w")
    real_file.write(contents)
    real_file.close()
    myprint(" - Created source file    " + files['analysis_source'][analysis])
    
    if parameters["cr"] == "y":
        if parameters["experiment"] == 'A':  
          template_file = open(files['analysis_template_CR_source_atlas'], "r")
        if parameters["experiment"] == 'C':  
          template_file = open(files['analysis_template_CR_source_cms'], "r")          
        contents = template_file.read()
        template_file.close()    
        contents = contents.replace("@@analysis@@", analysis).replace("@@Analysis@@", analysis.capitalize()).replace("@@ANALYSIS@@", analysis.upper())
        contents = contents.replace("@@lumi@@", parameters["lumi"])
        contents = contents.replace("@@author@@", parameters["author"])
        contents = contents.replace("@@authoremail@@", parameters["authoremail"])
        contents = contents.replace("@@longInfo@@", str(parameters["long_info"]).replace("['", '"@#').replace("']", '\\n"').replace("', '", '\\n"\n         "@#'))
        real_file = open(files['analysis_CR_source'][analysis], "w")
        real_file.write(contents)
        real_file.close()
        myprint(" - Created source file    " + files['analysis_CR_source'][analysis])
    
    template_file = open(files['analysis_template_header'], "r")
    contents = template_file.read()
    template_file.close()
    contents = contents.replace("@@author@@", parameters["author"])
    contents = contents.replace("@@authoremail@@", parameters["authoremail"])
    contents = contents.replace("@@analysis@@", analysis).replace("@@Analysis@@", analysis.capitalize()).replace("@@ANALYSIS@@", analysis.upper())
    if parameters["cr"] == "y":
        contents = contents.replace("@@BEGINCR@@", "").replace("@@ENDCR@@", "")
    else:
        contents = re.sub(re.compile(r"@@BEGINCR@@.*@@ENDCR@@", re.DOTALL), "", contents)
    real_file = open(files['analysis_header'][analysis], "w")
    real_file.write(contents)
    real_file.close()
    myprint(" - Created header file    " + files['analysis_header'][analysis])
        
    template_file = open(files['analysis_makefile'], "r")
    contents = template_file.read()
    template_file.close()
    contents = contents.replace("doAnalysis_SOURCES += ", "doAnalysis_SOURCES += src/analyses/" + analysis + ".cc include/analyses/" + analysis + ".h ")
    if parameters["cr"] == "y":
        contents = contents.replace("doAnalysis_SOURCES += ", "doAnalysis_SOURCES += src/analyses/" + analysis + "_CR.cc ")
    real_file = open(files['analysis_makefile'], "w")
    real_file.write(contents)
    real_file.close()
    myprint(" - Updated Makefile")
    
    template_file = open(files['analysis_main'], "r")
    contents = template_file.read()
    template_file.close()
    contents = contents.replace("//@@extraheader@@", "#include \"" + analysis + ".h\" \n//@@extraheader@@")
    contents = contents.replace("//@@extracode@@", "        else if(analysis == \"" + analysis + "\") {\n            " + analysis.capitalize() + " a(inputFile, outputFolder, outputPrefix, xsect, xsecterr, branches, flags);\n            a.loopOverEvents();\n        }\n//@@extracode@@")
    if parameters["cr"] == "y":
        contents = contents.replace("//@@extracode@@", "        else if(analysis == \"" + analysis + "_CR\") {\n            " + analysis.capitalize() + "_CR a(inputFile, outputFolder, outputPrefix, xsect, xsecterr, branches, flags);\n            a.loopOverEvents();\n        }\n//@@extracode@@")
    real_file = open(files['analysis_main'], "w")
    real_file.write(contents)
    real_file.close()    
    myprint(" - Updated main source    main.cc")
    
def add_analysis_reference(parameters):
    """Creates a txt file in tabular form which shows all the reference data"""
    global printlevel
    analysis = parameters["analysis"]    
    files = get_analysis_files([analysis])
    reference_file = open(files['evaluation_reference'][analysis], "w")
    first_row = "SR    "
    for info in parameters["info_set"]:
        first_row += info + "    "
    reference_file.write(first_row + "\n")
    for sr in parameters["signal_regions"]:
        whole_row = sr + "    "
        for info in parameters["info_set"]:
            whole_row += parameters["reference_data"][sr][info] + "    "
        reference_file.write(whole_row + "\n")
    reference_file.close()    
    format_columnated_file(files["evaluation_reference"][analysis])
    myprint(" - Reference file created")
    
    # Adding the most important analysis information to the list_of_analysis file.
    list_file = open(files['list_of_analyses'], "a")
    list_file.write(analysis + "    " + str(len(parameters["signal_regions"])) + "    " + parameters["short_info"] + "    " + parameters["lumi"] + "    ")
    if parameters["cr"] == "y":
        list_file.write("yes    ")
    else:
        list_file.write("no    ")
    list_file.write("    " + parameters["author"] + "    " + parameters["authoremail"] + "\n")
    list_file.close()    
    format_columnated_file(files["list_of_analyses"])
    myprint(" - List of analyses updated")

 
def list_analyses():
    global Printlevel
    """Lists all analyses in "list of analyses"""
    files = get_standard_files()
    f = open(files['list_of_analyses'], "r")
    x = f.readline()
    myprint("#"*(len(x) + 4))
    myprint("# " + x[:-1] + " #")
    for x in f:
        myprint("# " + x[:-1] + " #") 
    myprint("#"*(len(x) + 4))

def create_analysis():
    """ Asks user for all information required to add an analysis to the framework. """
    global Printlevel
    myprint('This will collect all necessary information to create a full analysis and')
    myprint('Takes care for the creation and implementagtion of the source files into the code.')
    myprint('Please answer the following questions.')
    myprint('Attention: Your input is NOT saved before you answered all questions!')
    myprint('')
    #==========================================================================    
    parameters = dict()
    
    myprint('1. General Information to build analysis')
    parameters = ask_for_general_information(parameters)
    
    myprint('2. Information on Signal Regions')
    parameters["signal_regions"] = ask_multiline("List all signal regions (one per line, finish with an empty line):")    
    parameters["expectation_known"] = ask("Is the SM expectation B known? [(y)es, (n)o]?", "yn")
    if parameters["expectation_known"] == "y":
        parameters, S95obs_queue, S95exp_queue, S95_inputs = ask_for_signal_region_information(parameters)
    else:
        myprint("Signal regions are registered but without any numbers associated to them.")
        myprint("IMPORTANT: The analysis will be created and can then be used like any other")
        myprint("           analysis. CheckMATE will skip the model exclusion tests as long as")
        myprint("           the expectation is not known. You can e.g. use CheckMATE on background")
        myprint("           samples to estimate B and dB. As soon as you know these numbers, ")
        myprint("           run the AnalysisManager again and use the (e)dit feature to add them.")
        ask("Press key to continue!", "@")
         
    myprint('')
    myprint("3. Settings for Detector Simulation")
    parameters = ask_for_detector_information(parameters)
    
     # Loop to wait for S95 calculations to finish
    if parameters["expectation_known"] == "y":
      check_queue_progress(parameters, S95obs_queue, S95exp_queue, S95_inputs)    
    # Writes necessary files
    write_analysis_parameters(parameters)             
    add_analysis_sources(parameters)    
    if parameters["expectation_known"] == "y":
      add_analysis_reference(parameters)    
    Printlevel -= 1
    myprint("Analysis " + parameters["analysis"] + " has been added successfully!")
    myprint("Run 'autoreconf; ./configure {parameters}; make' to compile the new sources.")
    myprint("You can find the list '{parameters}' you configured CheckMATE originally with at the beginning of the file 'config.log'.")
    myprint("")

def edit_analysis():
    global Printlevel
    myprint('You can now edit or update some of the information for a given analysis.')
    
    # which analysis?
    files = dict()
    while True:
        analysis = ask("Enter the identifier of the analysis you want to edit: ") 
        files = get_analysis_files([analysis])        
        if os.path.isfile(files['analysis_settings'][analysis]):
            break
        myprint("ERROR: Analysis " + analysis + " not known!")
    
    # Read out analysis information
    parameters = read_analysis_parameters(analysis)
    myprint("Analysis " + analysis + " successfully read in.")
    while True:  
        myprint("Do you want to...")
        Printlevel += 1
        myprint("...list all defined entries? (l)")
        myprint("...restart the detector settings questions? (d)")
        myprint("...enter signal region numbers for observation and background? (n)")
        Printlevel -= 1
        #myprint("(Note that we do not allow individual entries to be changed as most of them are not")
        #myprint(" independent and/or values are imprinted in other files.)")
        what_to_edit = ask("", "dln")
        myprint("")
        if what_to_edit == "l":      
            myprint("Here are all defined objects in alphabetic order.")
            Printlevel += 1
            sorted_keys = parameters.keys()
            sorted_keys.sort()
            for p in sorted_keys:
                myprint(str(p)+":   "+str(parameters[p]).replace("u'", "'")) # replace avoids that the unicde identifier is printed
            Printlevel -= 1      
            myprint("")
        if what_to_edit == "d":
            parameters = ask_for_detector_information(parameters)
            ask("Press any key to overwrite old detector settings (note that the old results are deleted!)", "@", True)
            write_analysis_parameters(parameters)
            myprint("Detector Information successfully changed")
            break
        if what_to_edit == "n":
            parameters, S95obs_queue, S95exp_queue, S95_inputs = ask_for_signal_region_information(parameters)
            parameters["expectation_known"] = "y"
            check_queue_progress(parameters, S95obs_queue, S95exp_queue, S95_inputs)  
            ask("Press any key to overwrite reference tables (note that existing old numbers are deleted!)", "@", True)
            write_analysis_parameters(parameters)
            add_analysis_reference(parameters)
            myprint("Detector Information successfully changed")
            break
    
    
def remove_analysis():
    global Printlevel
    myprint('This will remove all source files and other appearances in the analysis framework.')
    myprint('(You can re-add the analysis as long as you keep the settings file in the /data directory).')
    Printlevel += 1
    analysis = ask("Analysis Name: ")
    files = get_analysis_files([analysis])
    jfile = open(files['analysis_settings'][analysis], "rb")
    parameters = json.loads(jfile.read())
    jfile.close()
    
    # Remove analysis-specific files                 
    os.remove(files["analysis_source"][analysis])
    if parameters["cr"] == "y":
        os.remove(files["analysis_CR_source"][analysis])
    os.remove(files["analysis_header"][analysis])    
    if parameters["expectation_known"] == "y":
        os.remove(files["evaluation_reference"][analysis])
    
    # Remove sources from Makefile
    template_file = open(files["analysis_makefile"], "r")
    contents = template_file.read()
    template_file.close()
    contents = contents.replace("src/analyses/" + analysis + ".cc include/analyses/" + analysis + ".h ", "")
    if parameters["cr"] == "y":
        contents = contents.replace("src/analyses/" + analysis + "_CR.cc ", "")
    real_file = open(files["analysis_makefile"], "w")
    real_file.write(contents)
    real_file.close()
    
    # Remove usage of analysis class in main analysis source
    template_file = open(files["analysis_main"], "r")
    contents = template_file.read()
    template_file.close()
    contents = contents.replace("#include \"" + analysis + ".h\" \n", "")
    contents = contents.replace("        else if(analysis == \"" + analysis + "\") {\n            " + analysis.capitalize() + " a(inputFile, outputFolder, outputPrefix, xsect, xsecterr, branches, flags);\n            a.loopOverEvents();\n        }\n", "")
    if parameters["cr"] == "y":
        contents = contents.replace("        else if(analysis == \"" + analysis + "_CR\") {\n            " + analysis.capitalize() + "_CR a(inputFile, outputFolder, outputPrefix, xsect, xsecterr, branches, flags);\n            a.loopOverEvents();\n        }\n", "")
    real_file = open(files["analysis_main"], "w")
    real_file.write(contents)
    real_file.close()
    
    # Remove line in analysis list
    template_file = open(files["list_of_analyses"], "r")
    contents = template_file.read()
    template_file.close()
    contents = re.sub(r"" + analysis + " .*\n", "", contents)
    real_file = open(files["list_of_analyses"], "w")
    real_file.write(contents)
    real_file.close()
    format_columnated_file(files["list_of_analyses"])
    myprint('All files, except for /data/' + analysis + '_var.j have been removed successfully.')    
    myprint('Keeping the _var.j file will allow you to conveniently re-add the analysis later.')
    

print """
   ____ _               _    __  __    _  _____ _____ 
  / ___| |__   ___  ___| | _|  \/  |  / \|_   _| ____|
 | |   | '_ \ / _ \/ __| |/ / |\/| | / _ \ | | |  _|  
 | |___| | | |  __/ (__|   <| |  | |/ ___ \| | | |___ 
  \____|_| |_|\___|\___|_|\_\_|  |_/_/   \_\_| |_____|
                                           
                    /\  _  _ |   _. _  |\/| _  _  _  _  _ _ 
                   /--\| )(_||\/_)|_)  |  |(_|| )(_|(_)(-|  
                              /                     _/      
                                         """
action = ask("""What would you like to do? 
    -(l)ist all analyses,
    -(a)dd a new analysis to CheckMATE,
    -(e)dit analysis information,
    -(r)emove an analysis from CheckMATE""", "lare")
if action == "a":
    create_analysis()
elif action == "l":
    list_analyses()
elif action == "e":
    edit_analysis()
elif action == "r":
    remove_analysis()


